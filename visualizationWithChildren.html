<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Debug Feed: React Learning</title>
    <link href="https://cdn.jsdelivr.net/npm/daisyui@5" rel="stylesheet" type="text/css" />
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <style>
        /* Custom styles for the dark mode Twitter-like feed */
        .feed-container {
            background-color: oklch(15% 0.01 240); /* Darker background for the feed area */
            border-left: 1px solid oklch(25% 0.01 240);
            border-right: 1px solid oklch(25% 0.01 240);
        }
        .card {
            background-color: oklch(18% 0.01 240); /* Slightly lighter card background */
            border-bottom: 1px solid oklch(25% 0.01 240);
            border-radius: 0; /* Remove card rounding for a feed look */
        }
        .card:last-child {
            border-bottom: none;
        }
        .card-body {
            padding: 1rem;
        }
        .reply-card {
            background-color: oklch(22% 0.01 240); /* Background for replies */
        }
        .collapse-title {
            background-color: oklch(20% 0.01 240);
        }
        .collapse-content {
            background-color: oklch(18% 0.01 240);
        }
        .badge-style {
            font-size: 0.65rem;
            padding: 0.25rem 0.5rem;
            font-weight: 600;
            text-transform: uppercase;
        }
    </style>
</head>
<body class="bg-base-300 text-base-content">
    <div class="min-h-screen">
        <!-- Header -->
        <div class="sticky top-0 z-10 bg-base-300/90 backdrop-blur-sm border-b border-base-content/20">
            <div class="max-w-2xl mx-auto p-4">
                <h1 class="text-xl font-bold">AI Debug Feed: React Learning</h1>
                <p class="text-sm opacity-70">Generated Data Visualization (Dark Mode)</p>
            </div>
        </div>

        <!-- Main Container -->
        <div class="max-w-2xl mx-auto feed-container">
            <div id="feed-content" class="space-y-0">
                <!-- Content will be injected here by the script -->
            </div>
        </div>
    </div>

    <script>
        const JSON_DATA = {
  "postsWithChildren": [
    {
      "posterName": "ReactSimplified",
      "text": "Welcome to your React learning feed! React is a powerful JavaScript library for building user interfaces. It lets you create reusable UI components, making your code more modular and easier to maintain.",
      "displayStyle": "BASIC",
      "children": [
        [
          {
            "text": "That focus on component reusability is key. It's what makes the codebase scalable, especially when working on complex applications. Functional components and Hooks made component logic so much cleaner too!",
            "posterName": "ReactLearnerX"
          },
          {
            "text": "I agree completely. But what about performance? Could you elaborate on how React's Virtual DOM contributes to making those UI updates fast and efficient? That concept often confuses beginners.",
            "posterName": "PerformanceSeeker"
          },
          {
            "text": "For anyone starting out, don't forget the amazing ecosystem! Tools like React Router for navigation and various state management libraries (Redux/Zustand) integrate seamlessly and extend React's capabilities significantly.",
            "posterName": "ToolingExpert"
          }
        ]
      ]
    },
    {
      "posterName": "CodeMaster",
      "text": "In React, you build your UI out of individual pieces called components. These components are like JavaScript functions that return HTML. You can create your own components and combine them to build complex user interfaces.",
      "displayStyle": "AI_IMAGE",
      "aiImagePrompt": "A visual representation of how individual React components (like buttons, forms, and headers) come together to form a complete web page. Show the components as puzzle pieces fitting together to create the final UI.",
      "children": [
        [
          {
            "text": "This analogy of components being like JavaScript functions returning HTML is spot on! It really clarifies the functional programming aspect. The biggest win for me is the reusability. How do you usually decide when a component is ready to be broken out into its own file/module?",
            "posterName": "ReactRookie"
          },
          {
            "text": "Great explanation! Since they are functions, how does data typically get passed down to these components? Is that where 'props' come into play, or is 'state' more important for data handling within the component itself?",
            "posterName": "DataFlowDave"
          },
          {
            "text": "Important distinction for newcomers: these are usually Functional Components now, using hooks for state and side effects. Remember that older React codebases might still use Class Components, which follow a different pattern, but Functional Components are the modern standard!",
            "posterName": "LegacyLearner"
          }
        ]
      ]
    },
    {
      "posterName": "JSXFan",
      "text": "Have you heard of JSX? It's a syntax extension for JavaScript that looks a lot like HTML. With JSX, you can write your UI right inside your JavaScript code, which makes creating components much more intuitive.",
      "displayStyle": "WEB_IMAGE",
      "imageSearchQuery": "Code snippet showing React JSX",
      "children": [
        [
          {
            "text": "I've started using it! It definitely feels natural when mixing JS logic and HTML structure. But since browsers don't understand JSX directly, how does Babel actually transform it into regular JavaScript calls (like React.createElement)? Is that process performance-heavy?",
            "posterName": "ReactRookie"
          }
        ],
        [
          {
            "text": "That's the magic of transpilation! Babel uses presets (like @babel/preset-react) to convert JSX tags into `React.createElement()` calls, or more recently, using the new JSX Transform, into calls to functions defined by the runtime, which is usually more optimized and doesn't require importing React just for JSX conversion.",
            "posterName": "CompilerNerd"
          }
        ],
        [
          {
            "text": "The co-location is the biggest win for me. Keeps templates and logic together. Just remember the one key difference: using `className` instead of `class` when applying CSS styles, otherwise JavaScript gets confused! That trips up so many beginners.",
            "posterName": "HTMLHater"
          }
        ]
      ]
    },
    {
      "posterName": "StateAndProps",
      "text": "Let's talk about `props` and `state`. `Props` (short for properties) are used to pass data from a parent component to a child component. Think of them as function arguments. `State`, on the other hand, is for managing a component's internal data. When the state of a component changes, React automatically re-renders the component to reflect the new data.",
      "displayStyle": "EXERCISE",
      "exerciseQuestions": [
        "In your own words, explain the main difference between props and state.",
        "Describe a scenario where you would use props to pass data.",
        "Explain how updating the state of a component affects what is displayed on the screen."
      ]
    },
    {
      "posterName": "Quiz",
      "text": "",
      "displayStyle": "QUIZ",
      "quizQuestions": [
        {
          "question": "What is React primarily used for?",
          "answers": [
            "Building mobile applications",
            "Building user interfaces for web and native apps",
            "Server-side rendering only"
          ],
          "correctIndex": 1
        },
        {
          "question": "What is JSX?",
          "answers": [
            "A new programming language",
            "A syntax extension for JavaScript",
            "A database query language"
          ],
          "correctIndex": 1
        },
        {
          "question": "How is data passed from a parent component to a child component?",
          "answers": [
            "Through the state",
            "Through props",
            "Through a direct API call"
          ],
          "correctIndex": 1
        }
      ]
    },
    {
      "posterName": "ReactGuru",
      "text": "The Virtual DOM is a key concept in React. It's a lightweight copy of the real DOM (the structure of your web page). When a component's state changes, React first updates the Virtual DOM, then it efficiently calculates the minimal changes needed to update the real DOM. This process is what makes React so fast and performant.",
      "displayStyle": "BASIC",
      "children": [
        [
          {
            "text": "Great explanation! This diffing algorithm is often misunderstood. It's not just that VDOM is faster; it's the *batched* updates and reconciliation that really optimize performance, preventing unnecessary direct DOM manipulation. What's a common pitfall developers encounter when relying too much on VDOM optimization?",
            "posterName": "DevScholar"
          }
        ],
        [
          {
            "text": "The common pitfall is misunderstanding `shouldComponentUpdate` or `React.memo`. If you write these functions incorrectly and always return true, you defeat the reconciliation benefits for that component, leading to unnecessary re-renders even if the props/state haven't truly changed.",
            "posterName": "ReactArchitect"
          }
        ],
        [
          {
            "text": "That makes sense. So essentially, the VDOM gives us performance *by default*, but developers must use tools like `memo` strategically to maintain high performance in complex applications, especially with large lists or frequent data updates.",
            "posterName": "DevScholar"
          }
        ],
        [
          {
            "text": "And remember Keys! Using stable, unique `key` props on list items is crucial for the VDOM's diffing algorithm to correctly identify and reuse existing elements. Without proper keys, the reconciliation can be inefficient, sometimes leading to unnecessary re-creation of elements.",
            "posterName": "KeyMaster"
          }
        ]
      ]
    },
    {
      "posterName": "ComponentQueen",
      "text": "There are two main types of components in React: functional components and class components. Functional components are simpler and are just JavaScript functions that return JSX. Class components are ES6 classes that extend from `React.Component` and have more features, like lifecycle methods.",
      "displayStyle": "AI_IMAGE",
      "aiImagePrompt": "An illustration comparing a simple, sleek functional component (represented by a streamlined object) next to a more complex, feature-rich class component (represented by a more intricate object with multiple interconnected parts).",
      "children": [
        [
          {
            "text": "This is a great breakdown! Since Hooks came out, I've heard that functional components can now handle state and lifecycle effects almost as well as class components. Is there still a reason to use class components in new projects?",
            "posterName": "ReactRookie"
          },
          {
            "text": "@ReactRookie Exactly! Hooks (useState, useEffect, etc.) basically bridge that gap. Most modern React development leans heavily on functional components now. Class components are mainly kept for legacy codebases or for implementing specific features like Error Boundaries.",
            "posterName": "HookMaster"
          }
        ],
        [
          {
            "text": "I also find functional components much easier to test because they often rely just on props (unless Hooks are heavily involved). The simpler arrow function syntax is a huge win for readability and reducing boilerplate too.",
            "posterName": "SimpleDev"
          }
        ]
      ]
    },
    {
      "posterName": "ReactDev",
      "text": "A fundamental rule in React is that component names must start with a capital letter. This is how React distinguishes between your custom components and regular HTML tags. For example, `<MyComponent />` is a React component, while `<div />` is a standard HTML element.",
      "displayStyle": "COMMENT",
      "children": [
        [
          {
            "text": "This is such a crucial distinction, especially for beginners who are moving from vanilla JavaScript/HTML. It's easy to forget that casing is how the parser decides whether to treat it as a function call (component) or a string (HTML tag).",
            "posterName": "JS_Guru"
          }
        ],
        [
          {
            "text": "Absolutely! It's one of those silent rules that makes JSX work. If you try to render `<myComponent />`, React will throw a warning or just treat it like an unknown HTML element. It's a common debugging hurdle.",
            "posterName": "ReactFanatic"
          },
          {
            "text": "Follow-up question: What about fragments? They look like custom components (`<></>`) but don't follow the casing rule. Is that because they are a built-in React feature handled specially by the compiler?",
            "posterName": "NewbieCoder"
          }
        ],
        [
          {
            "text": "That's a great question, @NewbieCoder. Fragments (`<></>` or `<React.Fragment>`) are syntax sugar implemented directly by the Babel/JSX transformer. They aren't 'components' in the traditional sense; they compile down to an array of children without adding an extra DOM node, which is a core React feature.",
            "posterName": "ReactDev"
          }
        ]
      ]
    },
    {
      "posterName": "MemeLord",
      "text": "When you finally understand the difference between props and state in React.",
      "displayStyle": "MEME",
      "imageSearchQuery": "Programmer celebrating at computer meme",
      "children": [
        [
          {
            "text": "That moment of clarity! For me, the breakthrough was realizing: Props are like arguments passed to a function (immutable from the component's perspective), and State is data managed internally by the component (mutable).",
            "posterName": "ReactGuru"
          },
          {
            "text": "Exactly! The data flow distinction is key. Props go down the component tree (parent to child), while State is self-contained. Violating that 'props down, state managed' rule leads to messy code quickly.",
            "posterName": "CodeClarity"
          },
          {
            "text": "So, if a component needs data that its children also need, but *only* the parent component should be able to change it, is that a clear case for lifting state up? Or would a context API be overkill there?",
            "posterName": "NewbieDev"
          },
          {
            "text": "Lifting state is usually the way to go for immediate parent/child relationships. Context or Redux are better suited for prop drilling issues across many levels or for global application data!",
            "posterName": "ReactArchitect"
          }
        ]
      ]
    },
    {
      "posterName": "Quiz",
      "text": "",
      "displayStyle": "QUIZ",
      "quizQuestions": [
        {
          "question": "What is the primary benefit of using the Virtual DOM?",
          "answers": [
            "It makes the code easier to read.",
            "It improves application performance by minimizing direct DOM manipulation.",
            "It allows you to write React code in different languages."
          ],
          "correctIndex": 1
        },
        {
          "question": "Which of the following is a valid way to define a simple React component?",
          "answers": [
            "function myComponent() { return <p>Hello</p>; }",
            "const MyComponent = () => <p>Hello</p>;",
            "class MyComponent extends React.Component { render() { return <p>Hello</p>; } }"
          ],
          "correctIndex": 1
        },
        {
          "question": "Why must React component names start with a capital letter?",
          "answers": [
            "It's just a convention with no real impact.",
            "To distinguish them from HTML tags.",
            "It helps with code formatting."
          ],
          "correctIndex": 1
        }
      ]
    },
    {
      "posterName": "HookMaster",
      "text": "React Hooks are a game-changer! Introduced in React 16.8, they let you use state and other React features in functional components. This means you can write more concise and readable code without needing to write a class.",
      "displayStyle": "BASIC",
      "children": [
        [
          {
            "text": "Absolutely! useEffect was the real revelation for me. Managing side effects and lifecycle methods in functional components feels so much cleaner than dealing with componentDidMount, componentDidUpdate, and componentWillUnmount separately.",
            "posterName": "StateSculptor"
          },
          {
            "text": "I totally agree about the conciseness! Quick question for the thread: If I'm coming from class components, what's the biggest mental shift when switching from this.setState to using useState?",
            "posterName": "JuniorDev_101"
          },
          {
            "text": "And let's not forget the power of Custom Hooks! Being able to extract complex stateful logic and reuse it across different components without prop drilling or context overuse is massive for maintaining large applications. It drastically improves separation of concerns.",
            "posterName": "ArchitectReact"
          }
        ]
      ]
    },
    {
      "posterName": "useStateFan",
      "text": "The `useState` hook is one of the most fundamental hooks. It allows you to add state to your functional components. You call `useState` with an initial state, and it returns the current state and a function to update it.",
      "displayStyle": "WEB_IMAGE",
      "imageSearchQuery": "React useState hook code example",
      "children": [
        [
          {
            "text": "Totally agree! It's the gateway hook. Quick question: when updating state based on the previous state (like incrementing a counter), is it always best practice to use the functional update form (setCount(prevCount => prevCount + 1))?",
            "posterName": "ReactNovice"
          }
        ],
        [
          {
            "text": "@ReactNovice Yes, absolutely! That ensures you're working with the most up-to-date state, especially in async updates or when React batches state changes. It prevents unexpected bugs due to stale closures.",
            "posterName": "HookMaster"
          }
        ],
        [
          {
            "text": "Also, a crucial reminder for everyone: when your state is an object or array, remember that the useState setter *replaces* the state entirely, it doesn't merge like this.setState in class components. You must manually spread the previous state to retain it!",
            "posterName": "StateArchitect"
          }
        ]
      ]
    },
    {
      "posterName": "useEffectPro",
      "text": "The `useEffect` hook lets you perform side effects in your functional components. This is where you would do things like fetching data from an API, setting up subscriptions, or manually changing the DOM.",
      "displayStyle": "AI_IMAGE",
      "aiImagePrompt": "A diagram showing the lifecycle of a React component with the useEffect hook. Illustrate the initial render, the execution of the effect, and how it can be triggered by changes in dependencies.",
      "children": [
        [
          {
            "text": "Great explanation! It's super important to remember the cleanup function returned by `useEffect`. That's how you avoid memory leaks, especially when dealing with subscriptions or timers, by tearing down the effect when the component unmounts.",
            "posterName": "ReactLearner1"
          }
        ],
        [
          {
            "text": "That makes sense! But what's the recommended way to handle the dependency array? Sometimes I run into infinite loops or stale closures when I try to optimize it. Should I always include every variable used inside the effect, or are there exceptions?",
            "posterName": "DependencyDilemma"
          }
        ],
        [
          {
            "text": "Agreed on side effects! For data fetching specifically, have you moved towards libraries like TanStack Query or SWR? They often handle caching, refetching, and background updates much cleaner than implementing everything manually inside `useEffect`. It feels like a better separation of concerns now.",
            "posterName": "ModernReactDev"
          }
        ]
      ]
    },
    {
      "posterName": "CodeExplorer",
      "text": "Ready to dive deeper into React? Check out the official documentation for more in-depth explanations and examples.",
      "displayStyle": "SOURCES",
      "sources": [
        "https://react.dev/"
      ],
      "children": [
        [
          {
            "text": "Absolutely! I found the section on Hooks, especially `useEffect`, to be incredibly detailed there. It really clarifies dependency arrays. Where do you recommend starting for someone familiar with components but new to context?",
            "posterName": "ReactNovice"
          }
        ],
        [
          {
            "text": "That's solid advice. Do you prefer the 'Learn React' pathway or jumping straight into the 'Reference' section? I sometimes get overwhelmed trying to switch between conceptual guides and API specifics.",
            "posterName": "DevQuery"
          }
        ],
        [
          {
            "text": "Don't forget the 'Thinking in React' section! It's timeless and crucial for understanding how to structure your application, regardless of whether you're using class components or functional components and hooks. It sets the foundational mindset.",
            "posterName": "SeniorDev"
          }
        ]
      ]
    },
    {
      "posterName": "Quiz",
      "text": "",
      "displayStyle": "QUIZ",
      "quizQuestions": [
        {
          "question": "What do React Hooks allow you to do?",
          "answers": [
            "Use state and other React features in functional components.",
            "Create animations in React.",
            "Connect to a database directly from a component."
          ],
          "correctIndex": 0
        },
        {
          "question": "What does the `useState` hook return?",
          "answers": [
            "Only the current state.",
            "The current state and a function to update it.",
            "Only a function to update the state."
          ],
          "correctIndex": 1
        },
        {
          "question": "What is the purpose of the `useEffect` hook?",
          "answers": [
            "To manage the component's state.",
            "To perform side effects like data fetching.",
            "To handle user input."
          ],
          "correctIndex": 1
        }
      ]
    },
    {
      "posterName": "ReactNinja",
      "text": "One of the key rules of hooks is that they must be called at the top level of your React function. You can't call them inside loops, conditions, or nested functions. This ensures that hooks are called in the same order each time the component renders.",
      "displayStyle": "BASIC",
      "children": [
        [
          {
            "text": "Absolutely! Violating this usually leads to unpredictable state updates and sometimes straight-up errors because React loses track of which state/effect corresponds to which hook call. Stable order is everything.",
            "posterName": "DevEnthusiast"
          },
          {
            "text": "This is why the `eslint-plugin-react-hooks` package is mandatory! It automatically catches these violations before they become runtime issues. Highly recommend setting up the `rules-of-hooks` rule.",
            "posterName": "LintLover"
          },
          {
            "text": "The fixed order is crucial because React stores the state and effect arrays internally, associating each index with a specific hook call. If the order changes (e.g., a hook is skipped due to a condition), Hook A suddenly gets the state of Hook B, causing chaos.",
            "posterName": "DeepDiver"
          }
        ]
      ]
    },
    {
      "posterName": "AdvancedReact",
      "text": "Beyond the basic hooks, there are others like `useContext` for accessing context, `useReducer` for more complex state management, and `useRef` for accessing DOM elements directly. You can even create your own custom hooks to share logic between components.",
      "displayStyle": "EXERCISE",
      "exerciseQuestions": [
        "Explain the 'rules of hooks' and why they are important.",
        "Describe a scenario where `useContext` would be more appropriate than passing props through multiple levels of components.",
        "What is a custom hook, and what are the benefits of creating one?"
      ]
    },
    {
      "posterName": "ReactCommunity",
      "text": "The React ecosystem is vast and constantly evolving. There are many libraries and frameworks built on top of React, like Next.js and Remix, that provide additional features like server-side rendering and routing.",
      "displayStyle": "WEB_IMAGE",
      "imageSearchQuery": "React ecosystem diagram",
      "children": [
        [
          {
            "text": "Absolutely! It feels like the biggest decision now isn't 'should I use React?' but 'which React meta-framework gives me the best dev experience and deployment story?' The rise of RSCs in Next.js and Remix's strong focus on web fundamentals (forms, actions) really pushes the boundaries of what a frontend team can deliver.",
            "posterName": "DevEnthusiast"
          },
          {
            "text": "For those still starting out, what's the general consensus on the 'easier' entry point: Next.js or Remix? Next feels dominant due to history and ecosystem size, but Remix's use of standard web APIs sometimes makes complex tasks feel surprisingly simpler.",
            "posterName": "FrontEndGuru"
          },
          {
            "text": "This evolution is crucial for performance. Plain client-side React can struggle with initial load times, but integrating SSR/SSG via these tools ensures great Lighthouse scores and better SEO out of the box. It’s no longer optional for large apps.",
            "posterName": "PerfOptimizer"
          },
          {
            "text": "I'm curious about the trade-offs in serverless deployment complexity. Next.js seems tightly coupled with Vercel for optimal function splitting, while Remix feels more adaptable to platforms like Netlify or Cloudflare Workers. Any insights?",
            "posterName": "CloudArchitect"
          }
        ]
      ]
    },
    {
      "posterName": "CodeChallenge",
      "text": "Time to put your knowledge to the test! Try building a simple to-do list application using React. You'll need to use components, state to manage the list of tasks, and props to pass data between components.",
      "displayStyle": "AI_IMAGE",
      "aiImagePrompt": "A simple and clean UI of a to-do list application. Show a list of tasks with checkboxes, an input field to add new tasks, and a button to add them.",
      "children": [
        [
          {
            "text": "Great challenge! Focusing on component reusability for the individual TodoItem and ensuring correct handling of unique keys when mapping over the list are crucial first steps here. Also, managing the input field state is a classic controlled component exercise.",
            "posterName": "ReactEnthusiast"
          },
          {
            "text": "For a simple to-do list, useState seems perfect for managing the tasks array. But at what point, if we added features like filtering, sorting, or complex edits, would switching to useReducer become a better practice?",
            "posterName": "JuniorDevLearner"
          },
          {
            "text": "Don't forget performance, especially if your list grows! When deleting or updating an item, make sure you are creating a *new* array (immutability) using map or filter rather than mutating the state directly. This ensures React re-renders correctly and efficiently.",
            "posterName": "PerformanceGeek"
          }
        ]
      ]
    },
    {
      "posterName": "Quiz",
      "text": "",
      "displayStyle": "QUIZ",
      "quizQuestions": [
        {
          "question": "Where should you call React Hooks?",
          "answers": [
            "Inside a loop",
            "At the top level of a React function",
            "Inside a conditional statement"
          ],
          "correctIndex": 1
        },
        {
          "question": "What is the purpose of a custom hook?",
          "answers": [
            "To create a new type of component.",
            "To share stateful logic between components.",
            "To replace the need for props."
          ],
          "correctIndex": 1
        },
        {
          "question": "Which of the following is a popular framework built on top of React?",
          "answers": [
            "Angular",
            "Vue.js",
            "Next.js"
          ],
          "correctIndex": 2
        }
      ]
    },
    {
      "nextTopicSuggestions": [
        "React Router",
        "State Management with Redux",
        "Next.js"
      ]
    }
  ]
};

        const feedContent = document.getElementById('feed-content');

        const styleMap = {
            BASIC: { badge: 'badge-ghost', border: '' },
            COMMENT: { badge: 'badge-secondary', border: '' },
            WEB_IMAGE: { badge: 'badge-accent', border: '' },
            AI_IMAGE: { badge: 'badge-primary', border: '' },
            MEME: { badge: 'badge-warning', border: '' },
            QUIZ: { badge: 'badge-info', border: 'border-l-4 border-info' },
            EXERCISE: { badge: 'badge-success', border: 'border-l-4 border-success' },
            SOURCES: { badge: 'badge-warning', border: 'border-l-4 border-warning' },
        };

        function renderReplies(children) {
            if (!children || children.length === 0) return '';

            const repliesHtml = children.flat().map(reply => `
                <div class="reply-card rounded-lg p-3">
                    <div class="font-semibold text-sm mb-1 text-primary">${reply.posterName}</div>
                    <div class="text-sm">${reply.text}</div>
                </div>
            `).join('');

            return `
                <div class="collapse collapse-arrow bg-base-200 mt-3">
                    <input type="checkbox" /> 
                    <div class="collapse-title text-sm font-medium min-h-0 py-2">
                        Replies (${children.flat().length})
                    </div>
                    <div class="collapse-content space-y-2 p-3">
                        ${repliesHtml}
                    </div>
                </div>
            `;
        }

        function renderQuiz(post) {
            const questionsHtml = post.quizQuestions.map((q, qIndex) => `
                <div class="bg-base-200 rounded-lg p-4">
                    <div class="font-semibold mb-3">${qIndex + 1}. ${q.question}</div>
                    <div class="form-control space-y-2">
                        ${q.answers.map((answer, aIndex) => `
                            <label class="label cursor-pointer justify-start gap-2">
                                <input type="radio" name="q${qIndex}" class="radio radio-info radio-sm" disabled />
                                <span class="label-text">${answer}</span>
                                ${aIndex === q.correctIndex ? '<span class="badge badge-success badge-xs">Correct!</span>' : ''}
                            </label>
                        `).join('')}
                    </div>
                </div>
            `).join('');

            return `
                <p class="font-semibold mb-4">📝 Test your React knowledge! Can you answer these questions?</p>
                <div class="space-y-3 mb-3">
                    ${questionsHtml}
                </div>
            `;
        }

        function renderExercise(post) {
            const exercisesHtml = post.exerciseQuestions.map((ex, exIndex) => `
                <div class="alert alert-success">
                    <div class="flex gap-3 items-start">
                        <div class="badge badge-lg">${exIndex + 1}</div>
                        <span>${ex}</span>
                    </div>
                </div>
            `).join('');

            return `
                <p class="font-semibold mb-4">💪 Practice makes perfect! Try these React exercises:</p>
                <div class="space-y-2 mb-3">
                    ${exercisesHtml}
                </div>
            `;
        }

        function renderSources(post) {
            const sourcesHtml = post.sources.map(source => {
                const url = new URL(source);
                return `
                    <a href="${source}" target="_blank" class="link link-hover flex items-center gap-3 p-3 bg-base-200 rounded-lg">
                        <div class="text-2xl">📖</div>
                        <div>
                            <div class="font-semibold text-sm">${url.pathname.split('/').pop() || url.hostname}</div>
                            <div class="text-xs opacity-60">${url.hostname}</div>
                        </div>
                    </a>
                `;
            }).join('');

            return `
                <p class="mb-4">Deep dive into the topic! Here are the best resources to learn more:</p>
                <div class="space-y-2 mb-3">
                    ${sourcesHtml}
                </div>
            `;
        }

        function renderPost(post, index) {
            const style = styleMap[post.displayStyle] || styleMap.BASIC;
            let contentHtml = `<p class="mb-3">${post.text}</p>`;

            if (post.displayStyle === 'QUIZ') {
                contentHtml = renderQuiz(post);
            } else if (post.displayStyle === 'EXERCISE') {
                contentHtml = renderExercise(post);
            } else if (post.displayStyle === 'SOURCES') {
                contentHtml = renderSources(post);
            }

            let imageHtml = '';
            if (post.displayStyle === 'AI_IMAGE') {
                imageHtml = `
                    <div class="badge badge-primary badge-sm mb-1">🎨 AI Generated</div>
                    <div class="text-xs opacity-60 italic mb-3">Prompt: "${post.aiImagePrompt}"</div>
                    <div class="w-full h-48 bg-base-300 flex items-center justify-center rounded-lg mb-3">
                        <span class="text-sm opacity-70">AI Image Placeholder: ${post.aiImagePrompt.substring(0, 50)}...</span>
                    </div>
                `;
            } else if (post.displayStyle === 'WEB_IMAGE' || post.displayStyle === 'MEME') {
                const label = post.displayStyle === 'MEME' ? 'Meme Search' : 'Image Search';
                const query = post.imageSearchQuery;
                imageHtml = `
                    <div class="text-xs opacity-60 mb-3">📸 ${label}: "${query}"</div>
                    <div class="w-full h-48 bg-base-300 flex items-center justify-center rounded-lg mb-3">
                        <span class="text-sm opacity-70">Image Placeholder: ${query.substring(0, 50)}...</span>
                    </div>
                `;
            }

            const replies = renderReplies(post.children);

            return `
                <div class="card bg-base-100 shadow ${style.border}">
                    <div class="card-body">
                        <div class="flex items-center gap-2 mb-2">
                            <h3 class="font-bold text-lg">${post.posterName}</h3>
                            <span class="badge badge-style ${style.badge} badge-sm">${post.displayStyle}</span>
                        </div>
                        
                        ${contentHtml}
                        ${imageHtml}

                        ${replies}
                    </div>
                </div>
            `;
        }

        function renderNextTopics(topics) {
            const topicList = topics.map(topic => `
                <li class="p-2 bg-base-200 rounded-lg">${topic}</li>
            `).join('');

            return `
                <div class="card bg-base-100 shadow border-t-4 border-info">
                    <div class="card-body">
                        <h3 class="font-bold text-xl mb-3 text-info">Next Suggested Topics</h3>
                        <ul class="space-y-2 list-disc list-inside">
                            ${topicList}
                        </ul>
                    </div>
                </div>
            `;
        }

        JSON_DATA.postsWithChildren.forEach((post, index) => {
            if (post.nextTopicSuggestions) {
                feedContent.innerHTML += renderNextTopics(post.nextTopicSuggestions);
            } else {
                feedContent.innerHTML += renderPost(post, index);
            }
        });
    </script>
</body>
</html>